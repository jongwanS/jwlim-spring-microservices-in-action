# 3. 스프링 부트로 마이크로서비스 구축하기

## 3.1 아키텍트 이야기 : 마이크로서비스 아키텍처 설계
- **아키텍트**는 애플리케이션의 각 부분이 잘 조립될 수 있도록 개발자가 작성할 코드 에대한 `스캐폴드`를 제공
- 마이크로서비스를 구축할때 프로젝트의 **아키텍트**는 다음 세가지 핵심 업무에 집중
  - `비즈니스 문제 분해`
  - `서비스 세분화 확정`
  - `서비스 인터페이스 정의`
### 3.1.1 비즈니스 문제 분해
- **비즈니스 문제를 기술하는 데 사용된 명사에 주목하라**
  - `계약`, `라이선스`, `자산`
- **동사에 주목하라**
  - 핵심 동사는 `조회하다` 와 `업데이트하다` 이다.
- **데이터 응집성을 찾아라**
  - 비즈니스 문제를 개별 부분으로 나눌 때 서로 **연관성이 높은 데이터 부분을 찾아야 한다.**
  - 마이크로서비스는 완전히 자기 데이터를 가져야 하기 때문이다.  

[그림 3-1] 명사 & 동사 요약 정리  
![img_1.png](images/ch03/img.png)              
출처 : 길벗 - 스프링 마이크로서비스 코딩 공작소 개정2판  

[그림 3-2] 고객과 나눈 대화를 기반으로 단순화한 데이터 모델  
![img_1.png](images/ch03/img_1.png)              
출처 : 길벗 - 스프링 마이크로서비스 코딩 공작소 개정2판

### 3.1.2 서비스 세분화 확정
- 데이터 모델을 단순화 => 마이크로서비스를 정의하는 과정을 시작
- **목표**는 이러한 주요 기능 부분을 서로 **독립적으로 빌드하고 배포**할 수 있는 완전한 `자립형 유닛`으로 추출
  - `유닛`은 데이터베이스를 공유하거나 개별적으로 가질 수 있다

- [그림 3-2] 애플리케이션 **코드**와 **데이터 모델**이 개별 조각으로 나뉨
![img_1.png](images/ch03/img_2.png)            
출처 : 길벗 - 스프링 마이크로서비스 코딩 공작소 개정2판  

#### [올바른 세분화 수준에 대한 정답]
- **마이크로서비스는 광범위하게 시작하고 더 작은 서비스로 리팩터링하는 것이 좋다**
  - 문제 영역을 작은 서비스로 분해하면 마이크로서비스가 작은 데이터 서비스로 전락할 수 있다.
- **서비스 간 교류하는 방식에 중점을 둔다**
  - `문제 도메인(영역)`에 대한 `큰단위의 인터페이스를 만드는 데 도움`이 된다.
  - 큰 것을 작게 리팩터링하는 것이 더 쉽다.
- **문제 도메인에 이해가 깊어지면서 서비스 책임도 계속 변한다**
  - 마이크로서비스는 단일 서비스로 시작 하여 여러 서비스로 분화되며 성장
  - 원래 서비스는 새로운 서비스들을 오케스트레이 션하고 애플리케이션의 다른 부분 기능을 캡슐화하는 역할
----
> [마이크로서비스 구축] 
> **계층별 분해**
> - UI 분해
> - 코드 우선 분해
> - 데이터 우선 분해
>   - 성능, 데이터 무결성, 트랜잭션
> **분해 패턴**
> - 교살자 무화과 패턴 : 모놀리스+MSA 동시운영(시스템의 일부를 점진적으로 대체)
> - 병렬 실행 : 모놀리식 기능과 새로운 마이크로서비스 기능을 나란히 실행해, 같은 요청을 제공하고 결과를 비교
> - 기능 토글

#### [너무 큰 마이크로서비스의 징후]
- **책임이 너무 많은 서비스**
- **다수 테이블에 걸쳐 데이터를 관리하는 서비스**
  - 여러 테이블에 데이터를 유지하거나 서비스의 데이터베이스 외부에 있는 테이블에 접근한다면 서비스가 너무 크다는 징조
  - `필자`는 마이크로서비스가 **3〜5개 이하의 테이블을 소유해야 한다는 지침**을 사용
- **테스트가 너무 많은 서비스**
  - 서비스는 시간이 지남에 따라 규모와 책임이 커질 수 있다

#### [너무 작은 마이크로서비스의 징후]
- **문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다**
  - 모든 것이 마이크로서비스가 되면 서비스에서 비즈니스 로직을 구성하는 것이 복잡하고 어려워진다.
  - 작업을 완료하는 데 필요한 서비스 수가 엄청나게 증가한다.
- **마이크로서비스가 지나치게 상호 의존적이다**
- **마이크로서비스가 단순한 CRUD 서비스 집합이 된다**

### 3.1.3 서비스 인터페이스 설계
**인터페이스는 직관적이어야 한다.**

- REST 철학을 수용하라.
  - **리처드슨의 성숙도 모델** (RESTful 서비스의 수준을 나타내는 모델)
  ````text
  - 레벨 0: POX(Plain Old XML)
    - `HTTP를 단순히 전송 수단으로 사용`
  - 레벨 1: 리소스 식별(URI)
    - `리소스에 대해 유일한 식별자(URI)를 사용`하여 리소스를 표현
    - ex) /post/{id}
  - 레벨 2: HTTP 메서드 활용
    - `URI Resources + HTTP Method`
      - 세 번째 단계에서는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 활용하여 CRUD(Create, Read, Update, Delete) 작업을 수행
    - ex) GET /post/1 (조회), DELETE /post/1 (삭제)
  - 레벨 3: `하이퍼미디어 컨트롤(HATEOAS)`
    - 하이퍼미디어 컨트롤(Hypermedia as the Engine of Application State, HATEOAS)을 적극적으로 활용
    - 클라이언트가 서버로부터 받은 리소스를 통해, `다음 가능한 동작을 결정`할 수 있게 해준다.
  ````
  - 서비스에 대한 REST 접근 방식은 표준 HTTP 동사(GET, PUT, POST, DELETE)를 사용하면서 서비스 호출 프로토콜로 HTTP를 수용하는 것이 핵심
- URI를 사용하여 의도를 전달하라.
- 요청과 응답에 JSON을 사용하라.
- HTTP 상태 코드로 결과를 전달하라.
  - 서비스 호출의 성공과 실패를 명시 하는 풍부한 표준 응답 코드 사용

## 3.2 마이크로서비스를 사용하지 말아야 할 때
- 분산 시스템 구축의 복잡성
- 가상 서버나 컨테이너 스프롤(실제 작업량 보다 더 많은 공간과 리소스를 차지 하는 현상)
- 애플리케이션 타입
- 데이터 트랜잭션과 일관성
### 3.2.1 분산 시스템 구축의 복잡성
- 모놀리식 애플리케이션에서 없던 **복잡성 발생**
- **높은 운영 성숙도도 필요**
- 조직에서 고도로 분산된 애플리케이션을 성공시키는 데 필요한 **자동화**와 **운영 작업**(모니터링, 확장 등)에 기꺼이 투자하지 않는 한 마이크로서비스 사용을 고려하지 않는 편이 좋다.

### 3.2.2 서버 또는 컨테이너 스프롤
- 마이크로서비스의 가장 일반적인 배포 모델은 **컨테이너당 하나의 마이크로서비스 인스턴스를 배포**
- 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡
> 마이크로서비스의 유연성은 이 서버들을 모두 실행하는 비용과 비교해 보아야 한다. 
> 람다 같은 함수 개발 을 고려하거나 동일한 서버에 더 많은 인스턴스를 추가하는 것처럼 다른 대안이 있을 수 있다.

### 3.2.3 애플리케이션 타입
- 부서 수준의 **소규모 애플리케이션**이나 **적은 사용자 기반의 애플리케이션**을 만들 때 마이크로서비스와 같은 분산 모델로 구축한다면 연관된 복잡성 때문에 그 가치보다 더 많은 비용이 발생할수 있다
- 마이크로서비스는 `재사용성`을 추구하며 `고도의 회복성과 확장성`이 필요한 대규모 애플리케이션을 구축하는 데 매우 유용한 아키텍처이다.
### 3.2.4 데이터 트랜잭션과 일관성
- 애플리케이션이 여러 데이터 소스에 걸쳐 복잡한 데이터를 집계하고 변환해야 한다면 마이크로서비스의 분산된 특성으로 이 작업은 어려워진다

## 3.3 개발자 이야기 : 스프링 부트와 자바
## 3.4 데브옵스 이야기 : 혹독한 런타임 구축
## 3.5 모든 관점 통합하기
## 3.6 요약
